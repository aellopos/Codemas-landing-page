<!DOCTYPE html>

<html lang="cs">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style.css?v2.1">
    <link rel="stylesheet" href="design.css?v2.1">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans&display=swap" rel="stylesheet">
    <link rel="shortcut icon" href="../pictures/pernicek.png">
    <title>Codemas 2021 III. dÃ­l</title>

    <!-- Google Tag Manager -->
    <script>
        (function (w, d, s, l, i) {
            w[l] = w[l] || [];
            w[l].push({
                'gtm.start': new Date().getTime(),
                event: 'gtm.js'
            });
            var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s),
                dl = l != 'dataLayer' ? '&l=' + l : '';
            j.async = true;
            j.src =
                'https://www.googletagmanager.com/gtm.js?id=' + i + dl;
            f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-KHCRZJL');
    </script>
    <!-- End Google Tag Manager -->
</head>

<body>
    <main>
        <div class="content">
            <h1>III. dÃ­l Codemas</h1>

            <p>Ahoj, dalÅ¡Ã­ dÃ­l je tady. Dnes se spoleÄnÄ› mrkneme na funkce a cykly, zÃ¡roveÅˆ si dÃ­ky novÃ½m znalostem vygenerujeme celou hernÃ­ plochu. Jdeme na to!</p>

            <h2>Funkce</h2>

            <p>MoÅ¾nÃ¡ jsi o funkcÃ­ch uÅ¾ slyÅ¡el/a, ale krÃ¡tkÃ© opakovÃ¡nÃ­ urÄitÄ› neuÅ¡kodÃ­. Funkce je skupina pÅ™Ã­kazÅ¯, kterou jsme nÄ›jak pojmenovali a kterou mÅ¯Å¾eme v programu volat opakovanÄ›. V programovÃ¡nÃ­ bychom se mÄ›li snaÅ¾it drÅ¾et principu DRY - Don't Repeat Yourself, neboli neopakuj se.</p>

            <p>ProvÃ¡dÃ­me-li v programu stejnou vÄ›c nÄ›kolikrÃ¡t, je tento kousek kÃ³du ideÃ¡lnÃ­m kandidÃ¡tem na vytvoÅ™enÃ­ funkce. Z naÅ¡eho opakovanÃ©ho kÃ³du vytvoÅ™Ã­me funkci, kterou pak z rÅ¯znÃ½ch mÃ­st programu jenom volÃ¡me.</p>

            <p>Funkce nÃ¡m tak umoÅ¾ÅˆujÃ­ zjednoduÅ¡it a zpÅ™ehlednit kÃ³d. Jsou prostÄ› skvÄ›lÃ© jako vÃ¡noÄnÃ­ dÃ¡rky! No, moÅ¾nÃ¡ ne ÃºplnÄ›, ale jsou tomu blÃ­zko. :)</p>

            <p>Funkci zaÄneme vÅ¾dy slovem <strong>function</strong>, za kterÃ½m nÃ¡sleduje jmÃ©no funkce (jak si my funkci pojmenujeme). Za jmÃ©nem jsou kulatÃ© zÃ¡vorky, ve kterÃ½ch jsou tzv. <strong>parametry</strong> funkce. Pokud funkce parametry nemÃ¡, zÅ¯stanou zÃ¡vorky prÃ¡zdnÃ© (ale bÃ½t tam musÃ­). A pak uÅ¾ jen do sloÅ¾enÃ½ch zÃ¡vorek {â€¦}, kterÃ© nÃ¡sledujÃ­ za klasickÃ½mi zÃ¡vorkami, napÃ­Å¡eme pÅ™Ã­kazy, kterÃ© chceme ve funkci mÃ­t.</p>

            <p>KdyÅ¾ chceme vykonat pÅ™Ã­kazy uvnitÅ™ funkce, staÄÃ­ funkci zavolat jejÃ­m jmÃ©nem s kulatÃ½mi zÃ¡vorkami na konci. Do kulatÃ½ch zÃ¡vorek se pÃ­Å¡ou parametry (vÃ­c pozdÄ›ji) nebo nic.</p>

            <p>PojÄme se teÄ vrhnout na vygenerovÃ¡nÃ­ plochy.</p>

            <p>ZÃ¡kladnÃ­ kostra funkce generateBoard vypadÃ¡ takto:</p>

            <p class="code">function generateBoard() {
// zde budou pÅ™Ã­kazy, kterÃ© chceme vykonat po zavolÃ¡nÃ­ funkce
}</p>

            <p>Co do nÃ­ ale napÃ­Å¡eme? Pokud jsme sprÃ¡vnÄ› pochopili princip, musÃ­me postupnÄ› prochÃ¡zet celÃ© to velkÃ© pole. RuÄnÄ› to ale rozhodnÄ› dÄ›lat nebudeme, pouÅ¾ijeme nÄ›co, Äemu se Å™Ã­kÃ¡ <strong>cyklus</strong>. Cyklus nÃ¡m dokÃ¡Å¾e opakovat urÄitÃ© bloky kÃ³du, kdyÅ¾ je to potÅ™eba. MÃ¡me nÄ›kolik rÅ¯znÃ½ch cyklÅ¯ (napÅ™. for, while, do-while), my v naÅ¡Ã­ hÅ™e vyuÅ¾ijeme primÃ¡rnÄ› cyklus <strong>for</strong>.</p>

            <p>TakovÃ½ cyklus vypadÃ¡ nÃ¡sledovnÄ›:</p>

            <p class="code">for (let i = 0; i < 10; i++) {
// zde budou pÅ™Ã­kazy, kterÃ© chceme opakovat v cyklu
}</p>

            <p>ZaÄneme klÃ­ÄovÃ½m slovem for a v klasickÃ½ch zÃ¡vorkÃ¡ch cyklus nastavÃ­me. NastavenÃ­ mÃ¡me rozdÄ›lenÃ© do tÅ™Ã­ ÄÃ¡stÃ­ (oddÄ›lujÃ­ se stÅ™ednÃ­kem):</p>

            <ul>
                <li>let i = 0 â€“ vytvÃ¡Å™Ã­me Å™Ã­dÃ­cÃ­ promÄ›nnou i</li>
                <li>i < 10 â€“ definujeme podmÃ­nku, do kdy se cyklus bude opakovat (v tomto pÅ™Ã­padÄ›, dokud bude i menÅ¡Ã­ jak 10)</li>
                <li>i++ â€“ to je tzv. inkrement, aby se nÃ¡m z cyklu nestal nekoneÄnÃ½ cyklus, potÅ™ebujeme mÄ›nit hodnotu Å™Ã­dÃ­cÃ­ promÄ›nnÃ© â€“ i++ nÃ¡m zajistÃ­, Å¾e se po kaÅ¾dÃ©m opakovÃ¡nÃ­ zvÃ½Å¡Ã­ hodnota promÄ›nnÃ© i o 1.</li>
            </ul>

            <p>VÅ¡e to, co je mezi sloÅ¾enÃ½mi zÃ¡vorkami, se bude opakovat. Jakmile se projedou vÅ¡echny pÅ™Ã­kazy, program pÅ™eskoÄÃ­ zpÄ›t ke kulatÃ½m zÃ¡vorkÃ¡m, zkontroluje, jestli hodnota Å™Ã­dÃ­cÃ­ promÄ›nnÃ© splÅˆuje podmÃ­nku a zvÃ½Å¡Ã­ hodnotu Å™Ã­dÃ­cÃ­ promÄ›nnÃ© o 1. Takhle se cyklus bude opakovat, dokud  nebude splnÄ›na podmÃ­nka.</p>

            <p>PojÄme si do kÃ³du pÅ™idat nÃ¡Å¡ cyklus, kterÃ½ bude prochÃ¡zet pole board:</p>
            
            <div class="btn-view">
                <a class="a-btn pvc" id="III-dil-pvc" href="#hd-content">PokraÄovat ve ÄtenÃ­</a>
            </div>

            <div id="hd-content">
                <p class="code">for (let y = 0; y < board.length; y++) {
}</p>

                <p>PrvnÃ­ ÄÃ¡st cyklu je nÃ¡m znÃ¡ma, nastavÃ­me si Å™Ã­dÃ­cÃ­ promÄ›nnou y s poÄÃ¡teÄnÃ­ hodnotou 0. V podmÃ­nce Å™Ã­kÃ¡me, dokud je y menÅ¡Ã­ neÅ¾ board.length. SchvÃ¡lnÄ› jsem v sekci o polÃ­ch mluvil i o jejich dÃ©lce â€“ pÅ™esnÄ› v takovÃ½ch pÅ™Ã­padech se nÃ¡m to hodÃ­, jelikoÅ¾ board.length nÃ¡m vrÃ¡tÃ­ hodnotu dÃ©lky pole board. NÄ›kdo moÅ¾nÃ¡ namÃ­tne, Å¾e znÃ¡me velikost pole board â€“ tedy 20. KaÅ¾dÃ½ program by mÄ›l bÃ½t ale co nejvÃ­ce obecnÃ½ a pÅ™ipravenÃ½ na zmÄ›ny, pokud bychom zmÄ›nili velikost pole na 21, musel bychom v tu chvÃ­li myslet na to, abychom to hodnotu vÅ¡ude zmÄ›nili, coÅ¾ nenÃ­ v lidskÃ½ch silÃ¡ch, proto se snaÅ¾ vÅ¾dy psÃ¡t obecnÃ© programy a myslet na tyto pÅ™Ã­pady.
                PrvnÃ­ cyklus mÃ¡me, ale jistÄ› ti doÅ¡lo, Å¾e sice prochÃ¡zÃ­me pole, ale uÅ¾ neprochÃ¡zÃ­me ta pole, kterÃ¡ se nachÃ¡zejÃ­ na tÄ›ch indexech. Proto musÃ­me vloÅ¾it do cyklu dalÅ¡Ã­ cyklus, kterÃ½ se o to postarÃ¡.
                </p>

                <p class="code">for (let y = 0; y < board.length; y++) {
    for (let x = 0; x < board[y].length; x++) {
    }
}</p>

                <p>DruhÃ½ cyklus je dost podobnÃ½, ale je tam pro nÃ¡s trochu neznÃ¡mÃ½ zÃ¡pis â€“ <strong>board[y].length</strong>. ZnamenÃ¡ to, Å¾e <strong>board[y]</strong> si vytÃ¡hne data z toho konkrÃ©tnÃ­ho indexu, tedy dalÅ¡Ã­ pole. Tyto cykly nÃ¡m zajistÃ­, Å¾e se projde kaÅ¾dÃ½ chlÃ­veÄek v kaÅ¾dÃ©m poli a my budeme schopni vykreslit mapu. NezbÃ½vÃ¡ nic jinÃ©ho neÅ¾ vloÅ¾it do druhÃ©ho cyklu podmÃ­nku, kterÃ¡ bude Å™Ã­kat â€“ pokud bude v danÃ©m chlÃ­veÄku 1, pak vykresli zeÄ, pokud bude v chlÃ­veÄku 0, nech blok prÃ¡zdnÃ½. Pro porovnÃ¡nÃ­ vyuÅ¾ijeme operÃ¡tor <strong>=== (rovnost)</strong>.</p>

                <p class="code">for (let y = 0; y < board.length; y++) {
    for (let x = 0; x < board[y].length; x++) {
        if (board[y][x] === 1) {
            tx.drawImage(wall, x * blockSize, y * blockSize, blockSize, blockSize)
        }
    }
}</p>
                 
                <p>Klasickou podmÃ­nku definujeme pomocÃ­ klÃ­ÄovÃ©ho slova if a do zÃ¡vorek napÃ­Å¡eme logickÃ½ vÃ½raz, ze kterÃ©ho vzejde pravda nebo nepravda. V podmÃ­nce reagujeme pouze na 1, protoÅ¾e 0 nÃ¡s nijak nezajÃ­mÃ¡ (nestane se pÅ™i nÃ­ nic).</p>

                <p>NaÅ¡e funkce generateBoard by mÄ›la vypadat nÃ¡sledovnÄ›:</p>

                <p class="code">function generateBoard() {
    for (let y = 0; y < board.length; y++) {
        for (let x = 0; x < board[y].length; x++) {
            if (board[y][x] === 1) {
                ctx.drawImage(wall, x * blockSize, y * blockSize, blockSize, blockSize)
            }
        }
    }
}</p>

                <p>Pro vykreslenÃ­ pouÅ¾ijeme funkci drawImage. Jako parametr pÅ™ijÃ­mÃ¡ obrÃ¡zek, pozici na ose x, pozici na ose y, vÃ½Å¡ku a Å¡Ã­Å™ku (pÅ™esnÄ› v tomto poÅ™adÃ­ a oddÄ›lenÃ© ÄÃ¡rkou).</p>

                <p>NynÃ­ uÅ¾ nÃ¡m zbÃ½vÃ¡ jen celou funkci zavolat. Na to taky pÅ¯jdeme chytÅ™e. Budeme chtÃ­t tuto funkci zavolat ve chvÃ­li, kdy se naÄte strÃ¡nka. JavaScript na tuto a podobnÃ© udÃ¡losti dokÃ¡Å¾e velice hezky reagovat, tzv. poslouchat. K â€poslechuâ€œ vyuÅ¾ijeme tzv. PoslouchaÄ udÃ¡lostÃ­.</p>

                <h2>PoslouchaÄ udÃ¡lostÃ­</h2>

                <p>PoslouchaÄ udÃ¡lostÃ­ bude Äekat (poslouchat), zda k udÃ¡losti nÃ¡hodou nedoÅ¡lo a pokud ano, tak zavolÃ¡ funkci, o kterÃ© jsme mu Å™ekli, Å¾e je tzv. ovladaÄ udÃ¡losti (event handler).</p>

                <p>PosluchaÄe udÃ¡losti pÅ™idÃ¡vÃ¡me pomocÃ­: objekt.addEventListener('udÃ¡lost', ovladaÄ).</p>

                <ul>
                    <li>Objekt je objekt, ke kterÃ©mu chceme ovladaÄ udÃ¡losti pÅ™ipojit.</li>
                    <li>UdÃ¡lost je textovÃ½ Å™etÄ›zec s nÃ¡zvem udÃ¡losti, na kterou se mÃ¡ Äekat.</li>
                    <li>OvladaÄ je nÃ¡zev funkce, kterÃ¡ se spustÃ­, kdyÅ¾ k udÃ¡losti dojde.</li>
                </ul>

                <p>VypadÃ¡ to sloÅ¾itÄ›, ale zas tak sloÅ¾itÃ© to nenÃ­. UkaÅ¾me si to na konkrÃ©tnÃ­m pÅ™Ã­kladu, a to na naÅ¡em kÃ³du z minula:</p>

                <p class="code">window.addEventListener("load", generateBoard)</p>

                <p>TÃ­mto Å™Ã¡dkem jsme JavaScriptu Å™ekli, Å¾e objekt <strong>window</strong> (okno prohlÃ­Å¾eÄe) bude Äekat, dokud v nÄ›m nebude vÅ¡echno naÄtenÃ© (udÃ¡lost <strong>load</strong>). KdyÅ¾ se naÄte kompletnÃ­ obsah strÃ¡nky vÄetnÄ› vÅ¡ech obrÃ¡zkÅ¯, fontÅ¯ apod., tak dojde k udÃ¡losti a zavolÃ¡ se funkce <strong>generateBoard</strong> - tedy ta funkce, kterÃ¡ je zodpovÄ›dnÃ¡ za aktualizaci veÅ¡kerÃ©ho dÄ›nÃ­ ve hÅ™e.</p>
                
                <h2>Na zÃ¡vÄ›r</h2>

                <p>Na svÄ›tÄ› mÃ¡me krÃ¡snÃ© bludiÅ¡tÄ›! DobrÃ¡ prÃ¡ce! ğŸ˜Š</p>
                <p>
                    CelÃ½ kÃ³d z dneÅ¡ka najdeÅ¡ <a target="_blank" href="https://replit.com/@aellopos/03-1">zde</a>. DoufÃ¡m, Å¾e se ti to lÃ­bilo a uvidÃ­me se zase u dalÅ¡Ã­ho dÃ­lu.
                </p>

                <p>Pokud s nÄ›ÄÃ­m bojujeÅ¡, neboj se nÃ¡m napsat pod pÅ™Ã­spÄ›vek na naÅ¡Ã­ <a
                    href="https://www.facebook.com/events/1276972712744334?ref=newsfeed" target="_blank">facebookovÃ©
                    udÃ¡losti</a>, rÃ¡di ti pomÅ¯Å¾eme. K dotazu ideÃ¡lnÄ› poÅ¡li i URL adresu s odkazem na tvÅ¯j projekt.
                :) </p>

                <p>ZaÄala sis pohrÃ¡vat s myÅ¡lenkou, Å¾e bys chtÄ›la prozkoumat IT trochu vÃ­c? PodÃ­vej se na <a id="III-dil-kurzy"  href="https://www.czechitas.cz/kalendar" target="_blank">nabÃ­dku kurzÅ¯ od Czechitas</a>, kteÅ™Ã­ se zamÄ›Å™ujÃ­ na vzdÄ›lÃ¡vÃ¡nÃ­ pÅ™evÃ¡Å¾nÄ› Å¾en a dÄ›tÃ­ v IT. Jak si vybrat vhodnÃ½ kurz zjistÃ­Å¡ <a id="III-dil-blog" href="https://www.czechitas.cz/blog/jak-si-vybrat-kurz" target="_blank">zde</a>.</p>

                <p>Michal z Czechitas</p>
            </div>
        </div>
    </main>

    <script src="script.js"></script>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-KHCRZJL" height="0" width="0"
        style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
</body>

</html>